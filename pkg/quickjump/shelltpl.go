package quickjump

import (
	"github.com/gookit/goutil/errorx"
	"github.com/gookit/goutil/strutil/textutil"
	"github.com/gookit/goutil/sysutil"
)

// JumpBashTpl is the bash template for quick jump
var JumpBashTpl = `# Put the line below in ~/.bashrc or ~/bash_profile:
#
#   eval "$({{appBin}} tool jump shell bash)"
#   # set the bind func name is: j
#   eval "$({{appBin}} tool jump shell --bind j bash)"
#
# The following lines are autogenerated:

# completion func for {{bindFunc}}
# refer https://blog.csdn.net/qq_38883889/article/details/106543271
__jump_completion() {
    # example:
    # input 'jump hi'
    # - $COMP_LINE='jump hi'
    # - $term='hi'
    local term="${COMP_WORDS[COMP_CWORD]}"

    local commands=$({{appBin}} tool jump hint --only-path "$term")
    #    echo commands:
    #    echo $commands --- ${commands[@]}
    #    COMPREPLY=$commands
    COMPREPLY=($commands)
#    echo $COMPREPLY
#    echo ${COMPREPLY[2]}
#    echo all --- ${COMPREPLY[@]}
    #    COMPREPLY=("${commands[@]}")
    return
}

{{bindFunc}}() {
    local dir
    dir=$({{appBin}} tool jump get "$@")
    test -d "$dir" && cd "$dir" && {{appBin}} tool jump chdir "$dir"
}

# for use echo
#complete -o dirnames -C '__jump_completion' {{bindFunc}}
# for use COMPREPLY
complete -o dirnames -o plusdirs -F __jump_completion {{bindFunc}}
`

// JumpZshTpl is the zsh template for quick jump
var JumpZshTpl = `# Put the line below in ~/.zshrc or ~/zsh_profile:
#
#   eval "$({{appBin}} tool jump shell zsh)"
#   # set the bind func name is: j
#   eval "$({{appBin}} tool jump shell --bind j zsh)"
#
# for DEBUG:
#   set -x # start
#   set +x # stop
#   typeset -ft _jump_completion # start for given function
#   typeset +ft _jump_completion # stop
#
# The following lines are autogenerated:

# completion func for {{bindFunc}}
_jump_completion() {
    local state
    typeset -a commands histories

    # {{appBin}} app log "current $@ $#"
    {{appBin}} app log "var words: $words (w1: $words[1] w2: $words[2]) state: $state"

    # commands+=($({{appBin}} tool jump hint "$@"))
    commands+=($({{appBin}} tool jump hint --scope 1 $words[2]))
    histories+=($({{appBin}} tool jump hint --scope 2 $words[2]))
    #  _describe -t 'commands' commands
    _describe 'commands' commands -- histories
    _alternative \
        'files:filename:_files'
}

{{bindFunc}}() {
    local dir
    dir=$({{appBin}} tool jump get "$@")
    test -d "$dir" && cd "$dir" && {{appBin}} tool jump chdir "$dir"
}

# for use reply
# compctl -U -K _jump_completion {{bindFunc}}
# for use _describe
compdef _jump_completion '{{bindFunc}}'
# compctl -U -K _jump_completion {{bindFunc}}
`

// JumpPwshTpl is the pwsh template for quick jump
var JumpPwshTpl = `# Put the line below in $PROFILE or $PROFILE.CurrentUserAllHosts:
#
#   . ({{appBin}} tool jump shell pwsh)
# OR:
#   Invoke-Expression (&{{appBin}} tool jump shell pwsh)
# OR:
#   {{appBin}} tool jump shell pwsh | Out-String | Invoke-Expression
#
# The following lines are autogenerated:
#

# 为 Kite-Jump 函数创建别名 j
Set-Alias -Name {{bindFunc}} -Value Kite-Jump

#
# Kite-Jump 函数(windows 不区分大小写)
#
# 示例调用:
#   Kite-Jump home
#   Kite-Jump home config # path contains home and config
function Kite-Jump {
   param (
	   [Parameter(ValueFromRemainingArguments=$true)]
       [string[]]$Path
   )

   # Write-Host "DEBUG Path: $Path, args: $args"

   # 检查是否提供了路径参数
   if (-not $Path) {
       Write-Host "Please input target dir path or name for jump."
       Write-Host ""
       Write-Host "Usage: Jump [PATH or DIRNAME]"
       Write-Host ""
       Write-Host "Example:"
       Write-Host "  Jump home"
       return
   }

   # 执行命令并将输出存储在变量中
   $joinedPath = $Path -join " "
   $output = Invoke-Expression "kite.exe tool jump get $joinedPath"

   # 检查输出是否为空或无效
   if (-not $output) {
       Write-Host "Error: No valid directory found for input '$joinedPath'."
       return
   }

   # 尝试跳转目录
   try {
       Set-Location -Path $output -ErrorAction Stop
       # Write-Host "Dest: $output"
       Invoke-Expression "kite.exe tool jump chdir '$output'"
   } catch {
       Write-Host "Error: $output is not a valid directory."
   }
}
`

// GenScript generate the shell script for quick jump
func GenScript(shell, fnName string) (string, error) {
	tplStr, ok := ShellTplMap[shell]
	if !ok {
		return "", errorx.Rawf("not support shell: %s", shell)
	}

	vars := map[string]string{
		"bindFunc": fnName,
		"appBin":   sysutil.BinName(),
	}

	str := textutil.RenderSMap(tplStr, vars, "{{,}}")
	return str, nil
}
